{"name":"Swift-tutorial","tagline":"Swift tutorial","body":"Swift Tutorial\r\n--------------\r\n\r\nThis tutorial is viewable at: <TODO> http://swiftlang.org/tutorials/swift-tutorial-0.96 <FIX>\r\n\r\n\r\nIntroduction: Why Parallel Scripting?\r\n-------------------------------------\r\n\r\nSwift is a simple scripting language for executing many instances of\r\nordinary application programs on distributed parallel resources.\r\nSwift scripts run many copies of ordinary programs concurrently, using\r\nstatements like this:\r\n-----\r\nforeach protein in proteinList {\r\n  runBLAST(protein);\r\n}\r\n-----\r\nSwift acts like a structured \"shell\" language. It runs programs\r\nconcurrently as soon as their inputs are available, reducing the need\r\nfor complex parallel programming.  Swift expresses your workflow in a\r\nportable fashion: The same script runs on multicore computers,\r\nclusters, clouds, grids, and supercomputers.\r\n\r\nIn this tutorial, you'll be able to first try a few Swift examples\r\n(parts 1-3) on your local machine, to get a sense of the language.\r\nThen in parts 4-6 you'll run similar workflows on any resource\r\nyou may have access to such as clouds (Amazon Web Services), Cray HPC systems,\r\nclusters etc, and see how more complex workflows can be expressed\r\nwith Swift scripts.\r\n\r\nRunning the tutorial\r\n--------------------\r\n\r\nTo run the swift-tutorial, ensure that java (1.7+) and swift-0.96 is installed\r\non the machine you would be using to run the tutorials on.\r\n\r\nSwift modules are available on Beagle, Midway and OSGConnect. If a module\r\nis not available the following steps describe the installation procedure.\r\n\r\n[red]#TODO: Ensure latest modules are available on Beagle/Midway/OSGConnect#\r\n\r\nSwift installation\r\n~~~~~~~~~~~~~~~~~~\r\n\r\n[source, bash]\r\n-----\r\n# Download the swift-0.96 package\r\nwget http://swiftlang.org/packages/swift-0.96.tar.gz\r\n# Extract package\r\ntar xfz swift-0.96.tar.gz\r\n# Add swift to the PATH environment variable\r\nexport PATH=$PATH:/path/to/swift-0.96/bin\r\n-----\r\n\r\n\r\nGet the swift-tutorial repository\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\nClone the repository from github\r\n[source,bash]\r\n----\r\ngit clone https://github.com/yadudoc/swift-on-cloud.git\r\ncd swift-on-cloud\r\n----\r\n\r\nOr, download the zip file from github and unpack.\r\n[source,bash]\r\n----\r\n# Download\r\nwget https://github.com/yadudoc/swift-on-cloud/archive/master.zip\r\nunzip master.zip\r\nmv swift-on-cloud-master swift-on-cloud\r\ncd swift-on-cloud\r\n----\r\n\r\n\r\nSimple \"science applications\" for the workflow tutorial\r\n-------------------------------------------------------\r\n\r\nThis tutorial is based on two intentionally trivial example programs,\r\n`simulate.sh` and `stats.sh`, (implemented as bash shell scripts)\r\nthat serve as easy-to-understand proxies for real science\r\napplications. These \"programs\" behave as follows.\r\n\r\nsimulate.sh\r\n~~~~~~~~~~~\r\n\r\nThe simulation.sh script serves as a trivial proxy for any more\r\ncomplex scientific simulation application. It generates and prints a\r\nset of one or more random integers in the range [0-2^62) as controlled\r\nby its command line arguments, which are:\r\n\r\n-----\r\n$ ./app/simulate.sh --help\r\n./app/simulate.sh: usage:\r\n    -b|--bias       offset bias: add this integer to all results [0]\r\n    -B|--biasfile   file of integer biases to add to results [none]\r\n    -l|--log        generate a log in stderr if not null [y]\r\n    -n|--nvalues    print this many values per simulation [1]\r\n    -r|--range      range (limit) of generated results [100]\r\n    -s|--seed       use this integer [0..32767] as a seed [none]\r\n    -S|--seedfile   use this file (containing integer seeds [0..32767]) one per line [none]\r\n    -t|--timesteps  number of simulated \"timesteps\" in seconds (determines runtime) [1]\r\n    -x|--scale      scale the results by this integer [1]\r\n    -h|-?|?|--help  print this help\r\n$\r\n-----\r\n\r\nAll of thess arguments are optional, with default values indicated above as `[n]`.\r\n\r\nWith no arguments, simulate.sh prints 1 number in the range of\r\n1-100. Otherwise it generates n numbers of the form (R*scale)+bias\r\nwhere R is a random integer. By default it logs information about its\r\nexecution environment to stderr.  Here's some examples of its usage:\r\n\r\n-----\r\n$ simulate.sh 2>log\r\n       5\r\n$ head -4 log\r\n\r\nCalled as: /home/wilde/swift/tut/CIC_2013-08-09/app/simulate.sh:\r\nStart time: Thu Aug 22 12:40:24 CDT 2013\r\nRunning on node: login01.osgconnect.net\r\n\r\n$ simulate.sh -n 4 -r 1000000 2>log\r\n  239454\r\n  386702\r\n   13849\r\n  873526\r\n\r\n$ simulate.sh -n 3 -r 1000000 -x 100 2>log\r\n 6643700\r\n62182300\r\n 5230600\r\n\r\n$ simulate.sh -n 2 -r 1000 -x 1000 2>log\r\n  565000\r\n  636000\r\n\r\n$ time simulate.sh -n 2 -r 1000 -x 1000 -t 3 2>log\r\n  336000\r\n  320000\r\nreal    0m3.012s\r\nuser    0m0.005s\r\nsys     0m0.006s\r\n-----\r\n\r\nstats.sh\r\n~~~~~~~~\r\n\r\nThe stats.sh script serves as a trivial model of an \"analysis\"\r\nprogram. It reads N files each containing M integers and simply prints\r\nthe\\ average of all those numbers to stdout. Similarly to simulate.sh\r\nit logs environmental information to the stderr.\r\n\r\n-----\r\n$ ls f*\r\nf1  f2  f3  f4\r\n\r\n$ cat f*\r\n25\r\n60\r\n40\r\n75\r\n\r\n$ stats.sh f* 2>log\r\n50\r\n-----\r\n\r\n\r\nBasic of the Swift language with local execution\r\n------------------------------------------------\r\n\r\nA Summary of Swift in a nutshell\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n* Swift scripts are text files ending in `.swift` The `swift` command\r\nruns on any host, and executes these scripts. `swift` is a Java\r\napplication, which you can install almost anywhere.  On Linux, just\r\nunpack the distribution `tar` file and add its `bin/` directory to\r\nyour `PATH`.\r\n\r\n* Swift scripts run ordinary applications, just like shell scripts\r\ndo. Swift makes it easy to run these applications on parallel and\r\nremote computers (from laptops to supercomputers). If you can `ssh` to\r\nthe system, Swift can likely run applications there.\r\n\r\n* The details of where to run applications and how to get files back\r\nand forth are described in configuration files separate from your\r\nprogram. Swift speaks ssh, PBS, Condor, SLURM, LSF, SGE, Cobalt, and\r\nGlobus to run applications, and scp, http, ftp, and GridFTP to move\r\ndata.\r\n\r\n* The Swift language has 5 main data types: `boolean`, `int`,\r\n`string`, `float`, and `file`. Collections of these are dynamic,\r\nsparse arrays of arbitrary dimension and structures of scalars and/or\r\narrays defined by the `type` declaration.\r\n\r\n* Swift file variables are \"mapped\" to external files. Swift sends\r\nfiles to and from remote systems for you automatically.\r\n\r\n* Swift variables are \"single assignment\": once you set them you can't\r\nchange them (in a given block of code).  This makes Swift a natural,\r\n\"parallel data flow\" language. This programming model keeps your\r\nworkflow scripts simple and easy to write and understand.\r\n\r\n* Swift lets you define functions to \"wrap\" application programs, and\r\nto cleanly structure more complex scripts. Swift `app` functions take\r\nfiles and parameters as inputs and return files as outputs.\r\n\r\n* A compact set of built-in functions for string and file\r\nmanipulation, type conversions, high level IO, etc. is provided.\r\nSwift's equivalent of `printf()` is `tracef()`, with limited and\r\nslightly different format codes.\r\n\r\n* Swift's `foreach {}` statement is the main parallel workhorse of the\r\nlanguage, and executes all iterations of the loop concurrently. The\r\nactual number of parallel tasks executed is based on available\r\nresources and settable \"throttles\".\r\n\r\n* In fact, Swift conceptually executes *all* the statements,\r\nexpressions and function calls in your program in parallel, based on\r\ndata flow. These are similarly throttled based on available resources\r\nand settings.\r\n\r\n* Swift also has `if` and `switch` statements for conditional\r\nexecution. These are seldom needed in simple workflows but they enable\r\nvery dynamic workflow patterns to be specified.\r\n\r\nWe'll see many of these points in action in the examples below. Lets\r\nget started!\r\n\r\nPart 1: Run a single application under Swift\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\nThe first swift script, p1.swift, runs simulate.sh to generate a\r\nsingle random number. It writes the number to a file.\r\n\r\nimage::part01.png[\"p1 workflow\",align=\"center\"]\r\n\r\n.p1.swift\r\n-----\r\nsys::[cat ../part01/p1.swift]\r\n-----\r\n\r\n\r\nTo run this script, run the following command:\r\n-----\r\n$ cd part01\r\n$ swift p1.swift\r\nSwift 0.94.1 RC2 swift-r6895 cog-r3765\r\n\r\nRunID: 20130827-1413-oa6fdib2\r\nProgress:  time: Tue, 27 Aug 2013 14:13:33 -0500\r\nFinal status: Tue, 27 Aug 2013 14:13:33 -0500  Finished successfully:1\r\n$ cat sim.out\r\n      84\r\n$ swift p1.swift\r\n$ cat sim.out\r\n      36\r\n-----\r\n\r\nTo cleanup the directory and remove all outputs (including the log\r\nfiles and directories that Swift generates), run the cleanup script\r\nwhich is located in the tutorial PATH:\r\n\r\n[source,bash]\r\n-----\r\n$ cleanup\r\n-----\r\n\r\nNOTE: You'll also find a Swift configuration files in each `partNN`\r\ndirectory of this tutorial. These specify the environment-specific\r\ndetails of target computational resources where the application programs would be execute.\r\nThese swift configuration file will be explained in more\r\ndetail in parts 4-6, and can be ignored for now.\r\n\r\n\r\nPart 2: Running an ensemble of many apps in parallel with a \"foreach\" loop\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\nThe `p2.swift` script introduces the `foreach` parallel iteration\r\nconstruct to run many concurrent simulations.\r\n\r\nimage::part02.png[align=\"center\"]\r\n\r\n.p2.swift\r\n-----\r\nsys::[cat ../part02/p2.swift]\r\n-----\r\n\r\nThe script also shows an\r\nexample of naming the output files of an ensemble run. In this case, the output files will be named\r\n`output/sim_N.out`.\r\n\r\nIn part 2, we also update the apps file. Instead of using shell script (simulate.sh), we use\r\nthe equivalent python version (simulate.py). The new apps file now looks like this:\r\n\r\n-----\r\nsys::[cat ../part02/apps]\r\n-----\r\n\r\nSwift does not need to know anything about the language an application is written in. The application \r\ncan be written in Perl, Python, Java, Fortran, or any other language.\r\n\r\nTo run the script and view the output:\r\n-----\r\n$ cd ../part02\r\n$ swift p2.swift\r\n$ ls output\r\nsim_0.out  sim_1.out  sim_2.out  sim_3.out  sim_4.out  sim_5.out  sim_6.out  sim_7.out  sim_8.out  sim_9.out\r\n$ more output/*\r\n::::::::::::::\r\noutput/sim_0.out\r\n::::::::::::::\r\n      44\r\n::::::::::::::\r\noutput/sim_1.out\r\n::::::::::::::\r\n      55\r\n...\r\n::::::::::::::\r\noutput/sim_9.out\r\n::::::::::::::\r\n      82\r\n-----\r\n\r\nPart 3: Analyzing results of a parallel ensemble\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\nAfter all the parallel simulations in an ensemble run have completed,\r\nits typically necessary to gather and analyze their results with some\r\nkind of post-processing analysis program or script.  p3.swift\r\nintroduces such a postprocessing step. In this case, the files created\r\nby all of the parallel runs of `simulation.sh` will be averaged by by\r\nthe trivial \"analysis application\" `stats.sh`:\r\n\r\nimage::part03.png[align=\"center\"]\r\n\r\n.p3.swift\r\n----\r\nsys::[cat ../part03/p3.swift]\r\n----\r\n\r\nTo run:\r\n----\r\n$ cd part03\r\n$ swift p3.swift\r\n----\r\n\r\nNote that in `p3.swift` we expose more of the capabilities of the\r\n`simulate.sh` application to the `simulation()` app function:\r\n\r\n-----\r\napp (file o) simulation (int sim_steps, int sim_range, int sim_values)\r\n{\r\n  simulate \"--timesteps\" sim_steps \"--range\" sim_range \"--nvalues\" sim_values stdout=filename(o);\r\n}\r\n-----\r\n\r\n`p3.swift` also shows how to fetch application-specific values from\r\nthe `swift` command line in a Swift script using `arg()` which\r\naccepts a keyword-style argument and its default value:\r\n\r\n-----\r\nint nsim   = toInt(arg(\"nsim\",\"10\"));\r\nint steps  = toInt(arg(\"steps\",\"1\"));\r\nint range  = toInt(arg(\"range\",\"100\"));\r\nint values = toInt(arg(\"values\",\"5\"));\r\n-----\r\n\r\nNow we can specify that more runs should be performed and that each should run for more timesteps, and produce more that one value each, within a specified range, using command line arguments placed after the Swift script name in the form `-parameterName=value`:\r\n\r\n-----\r\n$ swift p3.swift -nsim=3 -steps=10 -values=4 -range=1000000\r\n\r\nSwift 0.94.1 RC2 swift-r6895 cog-r3765\r\n\r\nRunID: 20130827-1439-s3vvo809\r\nProgress:  time: Tue, 27 Aug 2013 14:39:42 -0500\r\nProgress:  time: Tue, 27 Aug 2013 14:39:53 -0500  Active:2  Stage out:1\r\nFinal status: Tue, 27 Aug 2013 14:39:53 -0500  Finished successfully:4\r\n\r\n$ ls output/\r\naverage.out  sim_0.out  sim_1.out  sim_2.out\r\n$ more output/*\r\n::::::::::::::\r\noutput/average.out\r\n::::::::::::::\r\n651368\r\n::::::::::::::\r\noutput/sim_0.out\r\n::::::::::::::\r\n  735700\r\n  886206\r\n  997391\r\n  982970\r\n::::::::::::::\r\noutput/sim_1.out\r\n::::::::::::::\r\n  260071\r\n  264195\r\n  869198\r\n  933537\r\n::::::::::::::\r\noutput/sim_2.out\r\n::::::::::::::\r\n  201806\r\n  213540\r\n  527576\r\n  944233\r\n-----\r\n\r\nNow try running (`-nsim=`) 100 simulations of (`-steps=`) 1 second each:\r\n\r\n-----\r\n$ swift p3.swift -nsim=100 -steps=1 \r\nSwift 0.94.1 RC2 swift-r6895 cog-r3765\r\n\r\nRunID: 20130827-1444-rq809ts6\r\nProgress:  time: Tue, 27 Aug 2013 14:44:55 -0500\r\nProgress:  time: Tue, 27 Aug 2013 14:44:56 -0500  Selecting site:79  Active:20  Stage out:1\r\nProgress:  time: Tue, 27 Aug 2013 14:44:58 -0500  Selecting site:58  Active:20  Stage out:1  Finished successfully:21\r\nProgress:  time: Tue, 27 Aug 2013 14:44:59 -0500  Selecting site:37  Active:20  Stage out:1  Finished successfully:42\r\nProgress:  time: Tue, 27 Aug 2013 14:45:00 -0500  Selecting site:16  Active:20  Stage out:1  Finished successfully:63\r\nProgress:  time: Tue, 27 Aug 2013 14:45:02 -0500  Active:15  Stage out:1  Finished successfully:84\r\nProgress:  time: Tue, 27 Aug 2013 14:45:03 -0500  Finished successfully:101\r\nFinal status: Tue, 27 Aug 2013 14:45:03 -0500  Finished successfully:101\r\n-----\r\n\r\nWe can see from Swift's \"progress\" status that the tutorial's default\r\n`swift.properties` parameters for local execution allow Swift to run up to 20\r\napplication invocations concurrently on the login node. We'll look at\r\nthis in more detail in the next sections where we execute applications\r\non the site's compute nodes.\r\n\r\n\r\nRunning applications on compute resources with Swift\r\n----------------------------------------------------\r\n\r\nPart 4: Running a parallel ensemble on compute nodes\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n`p4.swift` will run our mock \"simulation\"\r\napplications on compute nodes.  The script is similar to as\r\n`p3.swift`, but specifies that each simulation app invocation should\r\nadditionally return the log file which the application writes to\r\n`stderr`.\r\n\r\n////\r\n\r\nFIXME: need to revise this figure: drop prog:\r\n\r\n, making the parallel portion of the script behave like this:\r\n\r\nimage::part04.png[align=\"center\"]\r\n\r\n.p4.swift\r\n----\r\nsys::[cat ../part04/p4.swift]\r\n----\r\n////\r\n\r\nNow when you run `swift p4.swift` you'll see that two types output\r\nfiles will placed in the `output/` directory: `sim_N.out` and\r\n`sim_N.log`.  The log files provide data on the runtime environment of\r\neach app invocation. For example:\r\n\r\n-----\r\n$ cat output/sim_0.log \r\n\r\nCalled as: simulate.sh: --timesteps 1 --range 100 --nvalues 5\r\n\r\nStart time: Tue Oct 22 14:54:11 CDT 2013\r\nRunning as user: uid=5116(davidk) gid=311(collab) groups=311(collab),104(fuse),1349(swift),45053(swat)\r\nRunning on node: stomp\r\nNode IP address: 140.221.9.237 \r\n\r\nSimulation parameters:\r\n\r\nbias=0\r\nbiasfile=none\r\ninitseed=none\r\nlog=yes\r\nparamfile=none\r\nrange=100\r\nscale=1\r\nseedfile=none\r\ntimesteps=1\r\noutput width=8\r\n\r\nEnvironment:\r\n\r\nEDITOR=vim\r\nHOME=/homes/davidk\r\nJAVA_HOME=/nfs/proj-davidk/jdk1.7.0_01\r\nLANG=C\r\n....\r\n-----\r\n\r\n/////\r\nTo tell Swift to run the apps on compute nodes, we specify in the\r\n`apps` file that the apps should be executed on the `cloud` site\r\n(instead of the `localhost` site).  We can specify the location of\r\neach app in the third field of the `apps` file, with either an\r\nabsolute pathname or the name of an executable to be located in\r\n`PATH`). Here we use the latter form:\r\n\r\n-----\r\n$ cat apps\r\ncloud simulate simulate.sh\r\ncloud stats    stats.sh\r\n-----\r\n\r\nYou can experiment, for example, with an alternate version of stats.sh by specfying that app's location explicitly:\r\n\r\n-----\r\n$ cat apps\r\ncloud simulate simulate.sh\r\ncloud stats    /home/users/p01532/bin/my-alt-stats.sh\r\n-----\r\n\r\nWe can see that when we run many apps requesting a larger set of nodes (6), we are indeed running on the compute nodes:\r\n-----\r\n$ swift p4.swift -nsim=1000 -steps=1 \r\nSwift 0.94.1 RC2 swift-r6895 cog-r3765\r\n\r\nRunID: 20130827-1638-t23ax37a\r\nProgress:  time: Tue, 27 Aug 2013 16:38:11 -0500\r\nProgress:  time: Tue, 27 Aug 2013 16:38:12 -0500  Initializing:966\r\nProgress:  time: Tue, 27 Aug 2013 16:38:13 -0500  Selecting site:499  Submitting:500  Submitted:1\r\nProgress:  time: Tue, 27 Aug 2013 16:38:14 -0500  Selecting site:499  Stage in:1  Submitted:500\r\nProgress:  time: Tue, 27 Aug 2013 16:38:16 -0500  Selecting site:499  Submitted:405  Active:95  Stage out:1\r\nProgress:  time: Tue, 27 Aug 2013 16:38:17 -0500  Selecting site:430  Submitted:434  Active:66  Stage out:1  Finished successfully:69\r\nProgress:  time: Tue, 27 Aug 2013 16:38:18 -0500  Selecting site:388  Submitted:405  Active:95  Stage out:1  Finished successfully:111\r\n...\r\nProgress:  time: Tue, 27 Aug 2013 16:38:30 -0500  Stage in:1  Submitted:93  Active:94  Finished successfully:812\r\nProgress:  time: Tue, 27 Aug 2013 16:38:31 -0500  Submitted:55  Active:95  Stage out:1  Finished successfully:849\r\nProgress:  time: Tue, 27 Aug 2013 16:38:32 -0500  Active:78  Stage out:1  Finished successfully:921\r\nProgress:  time: Tue, 27 Aug 2013 16:38:34 -0500  Active:70  Stage out:1  Finished successfully:929\r\nProgress:  time: Tue, 27 Aug 2013 16:38:37 -0500  Stage in:1  Finished successfully:1000\r\nProgress:  time: Tue, 27 Aug 2013 16:38:38 -0500  Stage out:1  Finished successfully:1000\r\nFinal status: Tue, 27 Aug 2013 16:38:38 -0500  Finished successfully:1001\r\n\r\n$ grep \"on node:\" output/*log | head\r\noutput/sim_0.log:Running on node: nid00063\r\noutput/sim_100.log:Running on node: nid00060\r\noutput/sim_101.log:Running on node: nid00061\r\noutput/sim_102.log:Running on node: nid00032\r\noutput/sim_103.log:Running on node: nid00060\r\noutput/sim_104.log:Running on node: nid00061\r\noutput/sim_105.log:Running on node: nid00032\r\noutput/sim_106.log:Running on node: nid00060\r\noutput/sim_107.log:Running on node: nid00061\r\noutput/sim_108.log:Running on node: nid00062\r\n\r\n$ grep \"on node:\" output/*log | awk '{print $4}' | sort | uniq -c\r\n    158 nid00032\r\n    156 nid00033\r\n    171 nid00060\r\n    178 nid00061\r\n    166 nid00062\r\n    171 nid00063\r\n$ hostname\r\nraven\r\n$ hostname -f\r\nnid00008\r\n-----\r\n/////\r\nPerforming larger Swift runs\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\nTo test with larger runs, there are two changes that are required. The first is a \r\nchange to the command line arguments. The example below will run 1000 simulations\r\nwith each simulation taking 5 seconds.\r\n\r\n-----\r\n$ swift p6.swift -steps=5 -nsim=1000\r\n-----\r\n\r\nPart 5: Controlling the compute-node pools where applications run\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\nThis section is under development.\r\n\r\nPart 6: Specifying more complex workflow patterns\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\np6.swift expands the workflow pattern of p4.swift to add additional\r\nstages to the workflow. Here, we generate a dynamic seed value that\r\nwill be used by all of the simulations, and for each simulation, we\r\nrun an pre-processing application to generate a unique \"bias\r\nfile\". This pattern is shown below, followed by the Swift script.\r\n\r\nimage::part06.png[align=\"center\"]\r\n\r\n.p6.swift\r\n----\r\nsys::[cat ../part06/p6.swift]\r\n----\r\n\r\nNote that the workflow is based on data flow dependencies: each simulation depends on the seed value, calculated in this statement:\r\n-----\r\nseedfile = genseed(1);\r\n-----\r\nand on the bias file, computed and then consumed in these two dependent statements:\r\n-----\r\n  biasfile = genbias(1000, 20, simulate_script);\r\n  (simout,simlog) = simulation(steps, range, biasfile, 1000000, values, simulate_script, seedfile);\r\n-----\r\n\r\nTo run:\r\n----\r\n$ cd ../part06\r\n$ swift p6.swift\r\n----\r\n\r\nThe default parameters result in the following execution log:\r\n\r\n-----\r\n$ swift p6.swift\r\nSwift 0.94.1 RC2 swift-r6895 cog-r3765\r\n\r\nRunID: 20130827-1917-jvs4gqm5\r\nProgress:  time: Tue, 27 Aug 2013 19:17:56 -0500\r\n\r\n*** Script parameters: nsim=10 range=100 num values=10\r\n\r\nProgress:  time: Tue, 27 Aug 2013 19:17:57 -0500  Stage in:1  Submitted:10\r\nGenerated seed=382537\r\nProgress:  time: Tue, 27 Aug 2013 19:17:59 -0500  Active:9  Stage out:1  Finished successfully:11\r\nFinal status: Tue, 27 Aug 2013 19:18:00 -0500  Finished successfully:22\r\n-----\r\nwhich produces the following output:\r\n-----\r\n$ ls -lrt output\r\ntotal 264\r\n-rw-r--r-- 1 p01532 61532     9 Aug 27 19:17 seed.dat\r\n-rw-r--r-- 1 p01532 61532   180 Aug 27 19:17 bias_9.dat\r\n-rw-r--r-- 1 p01532 61532   180 Aug 27 19:17 bias_8.dat\r\n-rw-r--r-- 1 p01532 61532   180 Aug 27 19:17 bias_7.dat\r\n-rw-r--r-- 1 p01532 61532   180 Aug 27 19:17 bias_6.dat\r\n-rw-r--r-- 1 p01532 61532   180 Aug 27 19:17 bias_5.dat\r\n-rw-r--r-- 1 p01532 61532   180 Aug 27 19:17 bias_4.dat\r\n-rw-r--r-- 1 p01532 61532   180 Aug 27 19:17 bias_3.dat\r\n-rw-r--r-- 1 p01532 61532   180 Aug 27 19:17 bias_2.dat\r\n-rw-r--r-- 1 p01532 61532   180 Aug 27 19:17 bias_1.dat\r\n-rw-r--r-- 1 p01532 61532   180 Aug 27 19:17 bias_0.dat\r\n-rw-r--r-- 1 p01532 61532    90 Aug 27 19:17 sim_9.out\r\n-rw-r--r-- 1 p01532 61532 14897 Aug 27 19:17 sim_9.log\r\n-rw-r--r-- 1 p01532 61532 14897 Aug 27 19:17 sim_8.log\r\n-rw-r--r-- 1 p01532 61532    90 Aug 27 19:17 sim_7.out\r\n-rw-r--r-- 1 p01532 61532    90 Aug 27 19:17 sim_6.out\r\n-rw-r--r-- 1 p01532 61532 14897 Aug 27 19:17 sim_6.log\r\n-rw-r--r-- 1 p01532 61532    90 Aug 27 19:17 sim_5.out\r\n-rw-r--r-- 1 p01532 61532 14897 Aug 27 19:17 sim_5.log\r\n-rw-r--r-- 1 p01532 61532    90 Aug 27 19:17 sim_4.out\r\n-rw-r--r-- 1 p01532 61532 14897 Aug 27 19:17 sim_4.log\r\n-rw-r--r-- 1 p01532 61532 14897 Aug 27 19:17 sim_1.log\r\n-rw-r--r-- 1 p01532 61532    90 Aug 27 19:18 sim_8.out\r\n-rw-r--r-- 1 p01532 61532 14897 Aug 27 19:18 sim_7.log\r\n-rw-r--r-- 1 p01532 61532    90 Aug 27 19:18 sim_3.out\r\n-rw-r--r-- 1 p01532 61532 14897 Aug 27 19:18 sim_3.log\r\n-rw-r--r-- 1 p01532 61532    90 Aug 27 19:18 sim_2.out\r\n-rw-r--r-- 1 p01532 61532 14898 Aug 27 19:18 sim_2.log\r\n-rw-r--r-- 1 p01532 61532    90 Aug 27 19:18 sim_1.out\r\n-rw-r--r-- 1 p01532 61532    90 Aug 27 19:18 sim_0.out\r\n-rw-r--r-- 1 p01532 61532 14897 Aug 27 19:18 sim_0.log\r\n-rw-r--r-- 1 p01532 61532     9 Aug 27 19:18 average.out\r\n-rw-r--r-- 1 p01532 61532 14675 Aug 27 19:18 average.log\r\n-----\r\n\r\nEach sim_N.out file is the sum of its bias file plus newly \"simulated\" random output scaled by 1,000,000:\r\n\r\n-----\r\n$ cat output/bias_0.dat\r\n     302\r\n     489\r\n      81\r\n     582\r\n     664\r\n     290\r\n     839\r\n     258\r\n     506\r\n     310\r\n     293\r\n     508\r\n      88\r\n     261\r\n     453\r\n     187\r\n      26\r\n     198\r\n     402\r\n     555\r\n\r\n$ cat output/sim_0.out\r\n64000302\r\n38000489\r\n32000081\r\n12000582\r\n46000664\r\n36000290\r\n35000839\r\n22000258\r\n49000506\r\n75000310\r\n-----\r\n\r\nWe produce 20 values in each bias file. Simulations of less than that\r\nnumber of values ignore the unneeded number, while simualtions of more\r\nthan 20 will use the last bias number for all remoaining values past\r\n20.  As an exercise, adjust the code to produce the same number of\r\nbias values as is needed for each simulation.  As a further exercise,\r\nmodify the script to generate a unique seed value for each simulation,\r\nwhich is a common practice in ensemble computations.\r\n\r\nTips for Specific Resources\r\n---------------------------\r\n\r\nOpen Science Data Cloud\r\n~~~~~~~~~~~~~~~~~~~~~~~\r\n1. When you start instances on OSDC, use the standard Ubuntu image.\r\n2. Ensure that your SSH key is added to the instance for password login.\r\n3. Swift should run on the OSDC headnode.\r\n4. You can use the following command within coaster-service.conf to automatically\r\npopulate WORKER_HOSTS with the IP addresses of all active instances you have running.\r\n\r\n-----\r\nexport WORKER_HOSTS=$( nova list | grep ACTIVE | sed -e 's/^.*private=//' -e 's/ .*//' |sed ':a;N;$!ba;s/\\n/ /g' )\r\n-----\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}